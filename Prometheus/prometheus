Prometheus is an open-source technology designed to provide monitoring and alerting functionality for cloud-native environments, including Kubernetes. . 
It collects metrics from various sources, stores them in a time-series database, and allows for querying and visualization of the data. 
Prometheus supports multiple data sources, including Prometheus servers, Node Exporter, and other third-party exporters. 
It also offers a powerful query language called PromQL, which enables users to write complex queries to extract insights from the data.

Prometheus is often used in conjunction with other tools like Grafana, which provides a graphical interface for visualizing the metrics collected by Prometheus.
Key Feature:

1.Metric Collection:
Prometheus collects metrics from applications and systems via HTTP endpoints that expose metrics in a specific format.
Metrics are usually in the form of a time series (values recorded against timestamps).

2.Pull-Based Model:
Prometheus uses majorly pull-based model where it periodically scrapes metrics from target endpoints.
Push based method is minorly uses due to load and connectivities issues.

3.Multi-Dimensional Data Model:
Metrics are identified using a unique metric name and labels (key-value pairs) for dimensional data.
Example: http_requests_total{method="GET", status="200"}.

4.Powerful Query Language (PromQL):
Prometheus includes PromQL, a rich query language for slicing, dicing, and aggregating time-series data.

5.Time-Series Database (TSDB):
Prometheus comes with an embedded TSDB that stores metrics efficiently.

6.Service Discovery:
Prometheus supports dynamic target discovery using integrations with Kubernetes, Consul, EC2, and more.

7.Alerting:
Includes Alertmanager for sending notifications based on metric thresholds or anomalies.
Supports integrations with Slack, PagerDuty, email, and more.

Standalone and Distributed Monitoring:
Prometheus is designed to work as a standalone system. For scaling, it can be paired with tools like Thanos or Cortex.
############################################################################################################
Architecture of Prometheus
The Prometheus ecosystem typically consists of the following components:
1.Prometheus Server:
Core component that scrapes metrics, stores them in the TSDB, and executes queries.

2.Exporters:
Applications that expose metrics in Prometheus' format.
Examples: node_exporter for system metrics, blackbox_exporter for endpoint monitoring.

3.Alertmanager:
Handles alerts generated by Prometheus based on alerting rules.
Manages deduplication, grouping, and sending notifications.

4.Pushgateway:
Allows ephemeral or batch jobs to expose metrics by pushing them to Prometheus.

##################################################################################################################
Prometheus Workflow (Brief Overview)
Prometheus follows a systematic process to collect, store, query, and alert on metrics data. Here's a concise explanation:

1.Target Discovery:
Prometheus identifies monitoring targets via static configurations or dynamic service discovery mechanisms (e.g., Kubernetes, AWS, or Consul).

2.Metric Scraping:
Prometheus periodically scrapes metrics from targets by sending HTTP requests to their /metrics endpoints. Applications expose these metrics using client libraries or exporters.

3.Data Storage:
Collected metrics are stored in Prometheus' time-series database (TSDB), organized by metric names and labels (key-value pairs).

4.Querying (PromQL):
Prometheus uses PromQL (Prometheus Query Language) to retrieve and analyze stored metrics. Queries are used for debugging, reporting, and feeding data into dashboards.

5.Alerting:
Prometheus evaluates defined alerting rules. When conditions are met, it triggers alerts and sends them to Alertmanager, which handles notifications (e.g., Slack, email).

6.Visualization:
Metrics data is visualized using tools like Grafana or Prometheusâ€™ built-in UI to create dashboards for monitoring system health and performance.

##############################################################################################################################
Prometheus collects metrics in four primary types:
Each metric type serves a specific purpose and determines how data is stored, queried, and visualized.

1. Counter
Definition: A counter represents a monotonic increasing value. It can only increase or reset to zero (e.g., at process restart).
Use Case:
Tracking events over time, such as requests served, errors encountered, or tasks completed.
Example:
http_requests_total: Counts the total number of HTTP requests received by a service.

2. Gauge
Definition: A gauge represents a value that can go up and down, such as a measurement at a specific moment.
Use Case:
Monitoring system resources (e.g., memory usage, CPU load) or states (e.g., number of active connections).
Example:
memory_usage_bytes: Tracks current memory usage in bytes.
temperature_celsius: Reports the current temperature.

3. Histogram
Definition: A histogram samples observations (e.g., request durations or sizes) and counts them in buckets.
Use Case:
Measuring distributions, such as request latencies or response sizes.
Components:
<metric>_bucket: Contains counts for each bucket.
<metric>_sum: Tracks the sum of all observations.
<metric>_count: Counts the total number of observations.
Example:
http_request_duration_seconds_bucket: Buckets for request durations.

4. Summary
Definition: A summary also samples observations (e.g., request durations) but provides quantiles directly.
Use Case:
Calculating specific quantiles like 95th percentile latency.
Components:
<metric>_sum: Sum of all observations.
<metric>_count: Total number of observations.
Pre-computed quantiles (e.g., quantile="0.95").
Example:
http_request_duration_seconds_sum: Sum of request durations.
http_request_duration_seconds_count: Total number of requests.


Deploying an Application with Helm and Integrating Prometheus Monitoring
To deploy an application using Helm and set up Prometheus monitoring, follow these steps:

1. Prerequisites
Kubernetes Cluster: Ensure you have a running Kubernetes cluster.
Helm Installed: Install Helm on your local machine (helm version to confirm).
Prometheus Operator: Ensure Prometheus is deployed in your cluster (e.g., via the kube-prometheus-stack Helm chart).
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm install prometheus prometheus-community/kube-prometheus-stack
#####################################
2. Create Helm Chart for Your Application
Generate Helm Chart:

helm create my-app
cd my-app

Define Deployment and Service: Update the templates/deployment.yaml and templates/service.yaml to define your application.
#########################
# templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}-nginx
  labels:
    app: {{ .Release.Name }}-nginx
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ .Release.Name }}-nginx
  template:
    metadata:
      labels:
        app: {{ .Release.Name }}-nginx
    spec:
      containers:
        - name: nginx
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: 80
          resources:
            limits:
              cpu: {{ .Values.resources.limits.cpu }}
              memory: {{ .Values.resources.limits.memory }}
            requests:
              cpu: {{ .Values.resources.requests.cpu }}
              memory: {{ .Values.resources.requests.memory }}
##########################################
service.yaml:

# templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ .Release.Name }}-nginx
  labels:
    app: {{ .Release.Name }}-nginx
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: 80
  selector:
    app: {{ .Release.Name }}-nginx


###############################################
#Values.yml
replicaCount: 2

image:
  repository: nginx
  tag: "1.25.2"
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 80
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

resources:
  limits:
    cpu: "500m"
    memory: "256Mi"
  requests:
    cpu: "200m"
    memory: "128Mi"

ingress:
  enabled: false

nodeSelector: {}
tolerations: []
affinity: {}


############################################
3. Add Prometheus Integration
Expose Metrics in the Application: Ensure your application exposes metrics at a /metrics endpoint using a Prometheus client library (e.g., for Python, Java, etc.).

Add a ServiceMonitor: Create a ServiceMonitor resource in the Helm chart to enable Prometheus scraping.

templates/servicemonitor.yaml:
##################################################

Ensure the Prometheus Operator is configured to discover ServiceMonitors with the release: prometheus label.
######################################################
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: {{ .Release.Name }}-nginx-monitor
  labels:
    release: {{ .Release.Name }}
    app: nginx
spec:
  selector:
    matchLabels:
      app: nginx
      release: {{ .Release.Name }}
  endpoints:
    - port: http
      interval: 30s
      path: /metrics
      scheme: http
######################################################
4. Deploy the Helm Chart
Package and Install the Chart:

helm package .
helm install my-app ./my-app
Verify Deployment:

kubectl get pods
kubectl get servicemonitor
########################################################
5. View Metrics in Prometheus and Grafana
Access Prometheus Targets:

Navigate to the Prometheus UI: http://<prometheus-url>:9090.
Check if your application appears under Targets.
View Metrics in Grafana:

Add Prometheus as a data source in Grafana.
Create a dashboard to visualize your application metrics.
Final Notes
Ensure the ServiceMonitor labels match Prometheus' configuration for target discovery.
Use Grafana for better visualization and dashboards.
Regularly validate the /metrics endpoint to ensure it exposes meaningful metrics for monitoring.

########################################################
