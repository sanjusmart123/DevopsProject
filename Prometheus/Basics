Prometheus is an open-source technology designed to provide monitoring and alerting functionality for cloud-native environments, including Kubernetes. . 
It collects metrics from various sources, stores them in a time-series database, and allows for querying and visualization of the data. 
Prometheus supports multiple data sources, including Prometheus servers, Node Exporter, and other third-party exporters. 
It also offers a powerful query language called PromQL, which enables users to write complex queries to extract insights from the data.

Prometheus is often used in conjunction with other tools like Grafana, which provides a graphical interface for visualizing the metrics collected by Prometheus.
Key Feature:

1.Metric Collection:
Prometheus collects metrics from applications and systems via HTTP endpoints that expose metrics in a specific format.
Metrics are usually in the form of a time series (values recorded against timestamps).

2.Pull-Based Model:
Prometheus uses majorly pull-based model where it periodically scrapes metrics from target endpoints.
Push based method is minorly uses due to load and connectivities issues.

3.Multi-Dimensional Data Model:
Metrics are identified using a unique metric name and labels (key-value pairs) for dimensional data.
Example: http_requests_total{method="GET", status="200"}.

4.Powerful Query Language (PromQL):
Prometheus includes PromQL, a rich query language for slicing, dicing, and aggregating time-series data.

5.Time-Series Database (TSDB):
Prometheus comes with an embedded TSDB that stores metrics efficiently.

6.Service Discovery:
Prometheus supports dynamic target discovery using integrations with Kubernetes, Consul, EC2, and more.

7.Alerting:
Includes Alertmanager for sending notifications based on metric thresholds or anomalies.
Supports integrations with Slack, PagerDuty, email, and more.

Standalone and Distributed Monitoring:
Prometheus is designed to work as a standalone system. For scaling, it can be paired with tools like Thanos or Cortex.
############################################################################################################
Architecture of Prometheus
The Prometheus ecosystem typically consists of the following components:
1.Prometheus Server:
Core component that scrapes metrics, stores them in the TSDB, and executes queries.

2.Exporters:
Applications that expose metrics in Prometheus' format.
Examples: node_exporter for system metrics, blackbox_exporter for endpoint monitoring.

3.Alertmanager:
Handles alerts generated by Prometheus based on alerting rules.
Manages deduplication, grouping, and sending notifications.

4.Pushgateway:
Allows ephemeral or batch jobs to expose metrics by pushing them to Prometheus.

##################################################################################################################
Prometheus Workflow (Brief Overview)
Prometheus follows a systematic process to collect, store, query, and alert on metrics data. Here's a concise explanation:

1.Target Discovery:
Prometheus identifies monitoring targets via static configurations or dynamic service discovery mechanisms (e.g., Kubernetes, AWS, or Consul).

2.Metric Scraping:
Prometheus periodically scrapes metrics from targets by sending HTTP requests to their /metrics endpoints. Applications expose these metrics using client libraries or exporters.

3.Data Storage:
Collected metrics are stored in Prometheus' time-series database (TSDB), organized by metric names and labels (key-value pairs).

4.Querying (PromQL):
Prometheus uses PromQL (Prometheus Query Language) to retrieve and analyze stored metrics. Queries are used for debugging, reporting, and feeding data into dashboards.

5.Alerting:
Prometheus evaluates defined alerting rules. When conditions are met, it triggers alerts and sends them to Alertmanager, which handles notifications (e.g., Slack, email).

6.Visualization:
Metrics data is visualized using tools like Grafana or Prometheusâ€™ built-in UI to create dashboards for monitoring system health and performance.

##############################################################################################################################
Prometheus collects metrics in four primary types:
Each metric type serves a specific purpose and determines how data is stored, queried, and visualized.

1. Counter
Definition: A counter represents a monotonic increasing value. It can only increase or reset to zero (e.g., at process restart).
Use Case:
Tracking events over time, such as requests served, errors encountered, or tasks completed.
Example:
http_requests_total: Counts the total number of HTTP requests received by a service.

2. Gauge
Definition: A gauge represents a value that can go up and down, such as a measurement at a specific moment.
Use Case:
Monitoring system resources (e.g., memory usage, CPU load) or states (e.g., number of active connections).
Example:
memory_usage_bytes: Tracks current memory usage in bytes.
temperature_celsius: Reports the current temperature.

3. Histogram
Definition: A histogram samples observations (e.g., request durations or sizes) and counts them in buckets.
Use Case:
Measuring distributions, such as request latencies or response sizes.
Components:
<metric>_bucket: Contains counts for each bucket.
<metric>_sum: Tracks the sum of all observations.
<metric>_count: Counts the total number of observations.
Example:
http_request_duration_seconds_bucket: Buckets for request durations.

4. Summary
Definition: A summary also samples observations (e.g., request durations) but provides quantiles directly.
Use Case:
Calculating specific quantiles like 95th percentile latency.
Components:
<metric>_sum: Sum of all observations.
<metric>_count: Total number of observations.
Pre-computed quantiles (e.g., quantile="0.95").
Example:
http_request_duration_seconds_sum: Sum of request durations.
http_request_duration_seconds_count: Total number of requests.


